// Generated by CoffeeScript 1.10.0
(function() {
  var Notificator, Q, async, util,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  util = require('util');

  Q = require('q');

  Notificator = (function() {
    Notificator.prototype.defaultLanguage = 'en';

    Notificator.prototype.channels = [];

    Notificator.prototype.events = null;

    function Notificator(options1) {
      this.options = options1 != null ? options1 : {};
      this.options.debug = this.options.debug || false;
    }

    Notificator.prototype.registerEvent = function(event) {
      this.events = this.events || [];
      return this.events.push(event);
    };

    Notificator.prototype.registerEvents = function(events) {
      var event, i, len, results;
      results = [];
      for (i = 0, len = events.length; i < len; i++) {
        event = events[i];
        results.push(this.registerEvent(event));
      }
      return results;
    };

    Notificator.prototype.addChannel = function(name, channel) {
      return this.channels.push({
        name: name,
        channel: channel
      });
    };

    Notificator.prototype.getChannel = function(name) {
      var channel, i, len, ref;
      ref = this.channels;
      for (i = 0, len = ref.length; i < len; i++) {
        channel = ref[i];
        if (channel.name === name) {
          return channel;
        }
      }
      return null;
    };

    Notificator.prototype.getTemplates = function(channel, info, callback) {
      return channel.getTemplates(info, function(err, messages) {
        if (err) {
          return callback(err);
        }
        if (messages && !util.isArray(messages)) {
          messages = [messages];
        }
        return callback(null, messages);
      });
    };

    Notificator.prototype.getMessageFromTemplate = function(template, receiver, destination, data) {
      data = data || {};
      if (receiver) {
        data.receiver = receiver;
      }
      data.destination = destination;
      return template.getMessage(data);
    };

    Notificator.prototype.notify = function(event, receiver, data, options, callback) {
      var deferred;
      deferred = Q.defer();
      if (typeof data === 'function') {
        callback = data;
        data = options = void 0;
      } else if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      async.nextTick((function(_this) {
        return function() {
          if (_this.events && indexOf.call(_this.events, event) < 0) {
            return deferred.reject(new Error('unknown event ' + event));
          }
          data = data || {};
          data._event = event;
          return async.forEach(_this.channels, function(channelWrap, cb) {
            var channel, ref;
            if (util.isArray(options != null ? options.channels : void 0) && (ref = channelWrap.name, indexOf.call(options.channels, ref) < 0)) {
              return cb();
            }
            channel = channelWrap.channel;
            return channel.getDestinations(receiver, function(err, destinations) {
              if (err) {
                return cb(err);
              }
              return async.forEach(destinations, function(destination, cb2) {
                return _this.sendMessage(event, channel, receiver, destination, data, cb2);
              }, cb);
            });
          }, function(err) {
            if (err) {
              return deferred.reject(err);
            } else {
              return deferred.resolve();
            }
          });
        };
      })(this));
      return deferred.promise.nodeify(callback);
    };

    Notificator.prototype.notifyDestination = function(event, channelName, destination, data, options, callback) {
      var channel, channelWrap, deferred;
      deferred = Q.defer();
      if (typeof data === 'function') {
        callback = data;
        data = options = void 0;
      } else if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      channelWrap = this.getChannel(channelName);
      if (!channelWrap) {
        throw new Error('could not find channel \'' + channelName + '\'');
      }
      channel = channelWrap.channel;
      this.sendMessage(event, channel, null, channel.wrappedDestination(destination), data, function(err, info) {
        if (err) {
          return deferred.reject(err);
        } else {
          return deferred.resolve(info);
        }
      });
      return deferred.promise.nodeify(callback);
    };

    Notificator.prototype.sendMessage = function(event, channel, receiver, destination, data, callback) {
      var info;
      info = {
        event: event,
        destination: destination.language || this.defaultLanguage,
        data: data
      };
      return this.getTemplates(channel, info, (function(_this) {
        return function(err, templates) {
          if (err) {
            return callback(err);
          }
          return async.forEach(templates, function(template, cb) {
            var message;
            message = _this.getMessageFromTemplate(template, receiver, destination, data);
            if (_this.options.debug) {
              console.log('Notificator: sending message', message, ', to', destination);
              return async.nextTick(callback);
            } else {
              return channel.sendMessage(message, destination, cb);
            }
          }, callback);
        };
      })(this));
    };

    return Notificator;

  })();

  module.exports = Notificator;

}).call(this);
