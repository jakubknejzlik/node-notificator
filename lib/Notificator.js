// Generated by CoffeeScript 1.10.0
(function() {
  var Notificator, Q, async, util,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  util = require('util');

  Q = require('q');

  Notificator = (function() {
    Notificator.prototype.defaultLanguage = 'en';

    Notificator.prototype.channels = [];

    Notificator.prototype.events = [];

    function Notificator(options1) {
      this.options = options1 != null ? options1 : {};
    }

    Notificator.prototype.registerEvent = function(event) {
      return this.events.push(event);
    };

    Notificator.prototype.registerEvents = function(events) {
      var event, i, len, results;
      results = [];
      for (i = 0, len = events.length; i < len; i++) {
        event = events[i];
        results.push(this.registerEvent(event));
      }
      return results;
    };

    Notificator.prototype.addChannel = function(name, channel) {
      return this.channels.push({
        name: name,
        channel: channel
      });
    };

    Notificator.prototype.getTemplate = function(event, channel, language, callback) {
      return channel.getTemplate(event, language, function(err, message) {
        if (err) {
          return callback(err);
        }
        return callback(null, message);
      });
    };

    Notificator.prototype.parseTemplate = function(template, receiver, destination, data) {
      data = data || {};
      data.receiver = receiver;
      data.destination = destination;
      return template.parsedData(data);
    };

    Notificator.prototype.notify = function(event, receiver, data, options, callback) {
      var deferred;
      deferred = Q.defer();
      if (typeof data === 'function') {
        callback = data;
        data = options = void 0;
      } else if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      async.nextTick((function(_this) {
        return function() {
          if (indexOf.call(_this.events, event) < 0) {
            return deferred.reject(new Error('unknown event ' + event));
          }
          data = data || {};
          data._event = event;
          return async.forEach(_this.channels, function(channel, cb) {
            var _channel, ref;
            if (util.isArray(_this.options.channels) && (ref = channel.name, indexOf.call(_this.options.channels, ref) < 0)) {
              return cb();
            }
            _channel = channel.channel;
            return _channel.getDestinations(receiver, function(err, destinations) {
              if (err) {
                return cb(err);
              }
              return async.forEach(destinations, function(destination, cb) {
                return _this.getTemplate(event, _channel, destination.language || _this.defaultLanguage, function(err, event) {
                  var message;
                  if (err) {
                    return cb(err);
                  }
                  message = _this.parseTemplate(event, receiver, destination, data);
                  return channel.channel.sendMessage(message, destination, cb);
                });
              }, cb);
            });
          }, function(err) {
            if (err) {
              return deferred.reject(err);
            } else {
              return deferred.resolve();
            }
          });
        };
      })(this));
      return deferred.promise.nodeify(callback);
    };

    return Notificator;

  })();

  module.exports = Notificator;

}).call(this);
