// Generated by CoffeeScript 1.10.0
(function() {
  var Notificator, Q, async, util,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  util = require('util');

  Q = require('q');

  Notificator = (function() {
    Notificator.prototype.defaultLanguage = 'en';

    Notificator.prototype.channels = [];

    Notificator.prototype.events = null;

    function Notificator(options1) {
      this.options = options1 != null ? options1 : {};
      this.options.logging = this.options.logging || false;
    }

    Notificator.prototype.registerEvent = function(event) {
      this.events = this.events || [];
      return this.events.push(event);
    };

    Notificator.prototype.registerEvents = function(events) {
      var event, i, len, results;
      results = [];
      for (i = 0, len = events.length; i < len; i++) {
        event = events[i];
        results.push(this.registerEvent(event));
      }
      return results;
    };

    Notificator.prototype.addChannel = function(name, channel) {
      return this.channels.push({
        name: name,
        channel: channel
      });
    };

    Notificator.prototype.getChannel = function(name) {
      var channel, i, len, ref;
      ref = this.channels;
      for (i = 0, len = ref.length; i < len; i++) {
        channel = ref[i];
        if (channel.name === name) {
          return channel;
        }
      }
      return null;
    };

    Notificator.prototype.getTemplates = function(channel, info, callback) {
      return channel.getTemplates(info, function(err, messages) {
        if (err) {
          return callback(err);
        }
        if (messages && !util.isArray(messages)) {
          messages = [messages];
        }
        return callback(null, messages);
      });
    };

    Notificator.prototype.getMessageFromTemplate = function(template, receiver, destination, data) {
      data = data || {};
      if (receiver) {
        data.receiver = receiver;
      }
      data.destination = destination;
      return template.getMessage(data);
    };

    Notificator.prototype.notify = function(event, receivers, data, options, callback) {
      var deferred;
      deferred = Q.defer();
      if (!Array.isArray(receivers)) {
        receivers = [receivers];
      }
      if (typeof data === 'function') {
        callback = data;
        data = options = void 0;
      } else if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      async.nextTick((function(_this) {
        return function() {
          if (_this.events && indexOf.call(_this.events, event) < 0) {
            return deferred.reject(new Error('unknown event ' + event));
          }
          data = data || {};
          data._event = event;
          return async.forEach(receivers, function(receiver, cb) {
            _this.log('Notificator: sending event:', event, ', receiver:', receiver.toString());
            return async.forEach(_this.channels, function(channelWrap, cb) {
              var channel, ref;
              if (util.isArray(options != null ? options.channels : void 0) && (ref = channelWrap.name, indexOf.call(options.channels, ref) < 0)) {
                return cb();
              }
              channel = channelWrap.channel;
              return channel.getDestinations(receiver, function(err, destinations) {
                if (err) {
                  return cb(err);
                }
                return async.forEach(destinations, function(destination, cb2) {
                  return _this.sendMessage(event, channel, receiver, destination, data, cb2);
                }, cb);
              });
            }, cb);
          }, function(err) {
            if (err) {
              return deferred.reject(err);
            } else {
              return deferred.resolve();
            }
          });
        };
      })(this));
      return deferred.promise.nodeify(callback);
    };

    Notificator.prototype.notifyDestination = function(event, channelName, destinations, data, options, callback) {
      var channelWrap, deferred;
      deferred = Q.defer();
      if (typeof data === 'function') {
        callback = data;
        data = options = void 0;
      } else if (typeof options === 'function') {
        callback = options;
        options = void 0;
      }
      channelWrap = this.getChannel(channelName);
      if (!channelWrap) {
        throw new Error('could not find channel \'' + channelName + '\'');
      }
      if (!Array.isArray(destinations)) {
        destinations = [destinations];
      }
      async.map(destinations, (function(_this) {
        return function(destination, cb) {
          var channel, wrappedDestination;
          channel = channelWrap.channel;
          wrappedDestination = channel.wrappedDestination(destination);
          _this.log('Notificator: notifying destination: event', event, 'channel', channelName, ', to', wrappedDestination);
          return _this.sendMessage(event, channel, null, wrappedDestination, data, cb);
        };
      })(this), function(err, info) {
        if (err) {
          return deferred.reject(err);
        } else {
          if (destinations.length === 0) {
            return deferred.resolve(info[0]);
          } else {
            return deferred.resolve(info);
          }
        }
      });
      return deferred.promise.nodeify(callback);
    };

    Notificator.prototype.sendMessage = function(event, channel, receiver, destination, data, callback) {
      var info;
      info = {
        event: event,
        language: destination.language || this.defaultLanguage,
        data: data
      };
      return this.getTemplates(channel, info, (function(_this) {
        return function(err, templates) {
          if (err) {
            return callback(err);
          }
          return async.forEach(templates, function(template, cb) {
            var message;
            message = _this.getMessageFromTemplate(template, receiver, destination, data);
            _this.log('Notificator: sending message to', destination.toString(), ', data', JSON.stringify(message));
            if (_this.options.dummy) {
              return async.nextTick(cb);
            } else {
              return channel.sendMessage(message, destination, cb);
            }
          }, callback);
        };
      })(this));
    };

    Notificator.prototype.log = function() {
      if (this.options.logging) {
        return console.log.apply(console, arguments);
      }
    };

    return Notificator;

  })();

  module.exports = Notificator;

}).call(this);
