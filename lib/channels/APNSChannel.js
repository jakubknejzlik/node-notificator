// Generated by CoffeeScript 1.10.0
(function() {
  var APNSChannel, APNSTemplate, NotificatorChannel, apn, async, extend,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  apn = require('apn');

  async = require('async');

  extend = require('extend');

  NotificatorChannel = require('../NotificatorChannel');

  APNSTemplate = (function(superClass) {
    extend1(APNSTemplate, superClass);

    function APNSTemplate(alert, badge, sound, payload) {
      this.alert = alert;
      this.badge = badge;
      this.sound = sound;
      this.payload = payload;
    }

    APNSTemplate.prototype.getMessage = function(data) {
      var key, notification;
      data = APNSTemplate.__super__.getMessage.call(this, data);
      notification = new apn.Notification();
      for (key in data) {
        if (data[key]) {
          notification[key] = data[key];
        }
      }
      if (data.badge) {
        notification.badge = parseInt(data.badge);
      }
      return notification;
    };

    return APNSTemplate;

  })(NotificatorChannel.ChannelTemplate);

  APNSChannel = (function(superClass) {
    extend1(APNSChannel, superClass);

    function APNSChannel(options) {
      var feedbackOptions;
      this.connection = new apn.Connection(options);
      this.connection.on('error', console.error);
      feedbackOptions = extend(options, {
        production: options.production,
        batchFeedback: true,
        interval: options.feedbackInterval || 600
      });
      if (options.feedbackHandler) {
        this.feedback = new apn.feedback(feedbackOptions);
        this.feedback.on('feedback', function(feedbacks) {
          var i, item, items, len;
          items = [];
          for (i = 0, len = feedbacks.length; i < len; i++) {
            item = feedbacks[i];
            items.push({
              destination: item.device.toString(),
              date: new Date(item.time)
            });
          }
          return options.feedbackHandler(items);
        });
      }
      APNSChannel.__super__.constructor.call(this, options);
    }

    APNSChannel.prototype.sendMessage = function(message, destination, callback) {
      var device;
      device = new apn.Device(destination.destination);
      this.connection.pushNotification(message, device);
      return async.nextTick(function() {
        if (callback) {
          return callback();
        }
      });
    };

    APNSChannel.prototype.validateTemplate = function(template) {
      if (!template.alert && !template.payload && !template.sound && !template.badge) {
        throw new Error('apns template must have at least one attribute (available attributes alert, badge, sound, payload)');
      }
      return APNSChannel.__super__.validateTemplate.call(this, template);
    };

    APNSChannel.prototype.validateDestination = function(destination) {
      return true;
    };

    APNSChannel.prototype.transformTemplate = function(template) {
      return new APNSTemplate(template.alert, template.badge, template.sound, template.payload);
    };

    APNSChannel.prototype.wrappedDestination = function(destination) {
      if (destination != null ? destination.token : void 0) {
        destination.destination = destination.token;
        delete destination.token;
      }
      return APNSChannel.__super__.wrappedDestination.call(this, destination);
    };

    APNSChannel.prototype.name = function() {
      return 'APNS';
    };

    return APNSChannel;

  })(NotificatorChannel);

  APNSChannel.Template = APNSTemplate;

  module.exports = APNSChannel;

}).call(this);
